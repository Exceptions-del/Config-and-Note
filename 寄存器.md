 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vim 寄存器是一组用于保存文本的简单容器它们即可想剪贴板那样剪切,复制,粘贴文本 , 也可以和记录一系列按键操作,把它们录制为宏

- #### 无名寄存器
    
    - vim的 **删除**, **复制** 和 **粘贴** 命令设计的初衷是帮助人们轻松完成日常工作. **删除** **复制** 和 **粘贴** 在vim中操作的是寄存器, 而不是剪贴板. vim中普通模式下的 **删除** 都相当于 **剪切**, vim将这些 '删除' 的信息都放到了 **无名寄存器中**
    
    - 下表简单介绍了一些vim中使用无名寄存器的操作
    
        | 动作     | 作用                                      |
        |----------|-------------------------------------------|
        | x        | 删除光标下的字符                          |
        | p        | 将无名寄存器的内容粘贴到光标后            |
        | xp       | 调换光标下的字符后它后面的一个字符        |
        | dd       | 删除当前行                                |
        | ddp      | 调换当前行和它的下一行                    |
        | yy       | 复制当前行到`复制专用寄存器`              |
        | yiw      | 复制当前光标下的单词                      |
        | yaw      | 复制当前光标下的单词和一个空格            |
        | diw      | 删除当前光标所在的单词                    |
        | daw      | 删除当前光标所在的单词和一个空格          |
        | "_d{mod} | **真删除** ,不会放到寄存器里              |

    - 其中, y命令会将内容寄存到 `复制专用寄存器` 中, 它不会覆盖当前无名寄存器的内容, 可以使用 `"0` 来引用它. 如果希望能够像其他编辑器那样, 真正的删除, 而不希望影响无名寄存器的内容, 可以使用 **黑洞寄存器** -- `"_d{mod}` , 这是一个有去无回的寄存器, 当然, 如果我们误删了某个词, 我们还是可以通过 `u` 或 `<C-r>` 命令来恢复它

- #### vim寄存器

    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vim不使用单一的剪贴板进行剪切, 复制和粘贴操作, 而是为了这些操作提供了多组寄存器. 当使用删除, 复制和粘贴命令时, 可以明确指定它们中的某一个进行操作, 我们可以使用 `:reg {register}` 命令来查看某个寄存器的内容

    - 引用一个寄存器  
     
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vim 的删除, 复制和粘贴命令都会用到众多寄存器的中的某一个. 可以使用 `"{寄存器名}` 的方式引用一个方式指定要用的寄存器, 若指定, vim默认使用无名寄存器.
    
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 比如我们像把当前单词复制到寄存器 a 中, 可以执行 `"ayiw` ; 或者执行 `:bdd`, 把当前行剪切至寄存器 b 中. 只会调用时, 二者互相不干扰.  
        
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 除了普通命令外, vim 也提供用于删除, 复制和粘贴操作的Ex命令.  比如可以执行 `:delete c` , 把当前行剪切到寄存器 c 中, 然后再执行 `:put c` 命令将其粘贴到当前光标的下一行. 虽然这些操作看起来比普通模式更复杂, 但如果将它们和其他Ex命令结合起来使用, 或者用在vim脚本中, 将会更方便, 如 `:yank` 和 `:global` 一起使用.  
    
    - 无名寄存器( `""` )
      
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如果没有指定要使用的寄存器, vim将默认使用无名寄存器, 他可以用 `""` 表示. 如果要引用它,也一样需要引用两个双引号, 比如 `""p`, 它完全等同于命令 `p`  
        
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; `x` , `s` , `d{mod}` , `c{mod}` 和 `y{mod}` 命令都会覆盖无名寄存器的内容, 无论那种情况都可以加 `"{register}` 前缀的方式来指定某个寄存器, 但是无名寄存器总是是默认启用的, 实际上, 无名寄存器容易很容易被覆盖, 不小心会导致问题发生.  
        
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vim术语的命名确实有问题, `x` 和 `d{mod}` 经常被当成 **删除** 命令. 这其实是用词不当, 把它们理解为 **剪贴** 命令或许会更加合适. 无名寄存器经常找不到无想要的文本, 不过幸运的是, 复制专用寄存器要更可靠一些.
        
        vim术语对照表

        | 术语 | 广义   | vim    |
        |------|--------|--------|
        | 剪切 | cut    | delete |
        | 复制 | copy   | yank   |
        | 粘贴 | paste  | put    |
        | 修改 | change | change |

    - 复制专用寄存器( `"0` )
        
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当使用 `y{mod}` 命令时, 要复制的文本不仅会被覆盖到无名寄存器中, 而且也会被拷贝到复制专用寄存器中 , **复制专用寄存器** 可以用 `"0` 来引用.  
        
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 复制专用寄存器, 顾名思义, 仅当使用 `y{mod}` 命令时才会被覆盖. 换句话说, 使用 `x` , `s` , `c{mod}` , `d{mod}` 命令均不会覆盖该寄存器. (当然也可以使用 `"0` 的方式来覆盖它). 如果复制了一些文本, 可以缺陷该文本会一直保存在寄存器 0 中, 直到复制其他文本时才会被覆盖. 复制专用寄存器是稳定的, 而无名寄存器是易变的.  
    
    - 有名寄存器( `"a-"z` )  
    
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vim提供了一组以26个英文字母命名的有名寄存器, 这意味着可以剪切(` "ad{mod}` ), 复制( `"ay{mod}` )和粘贴( `"ap` )多达26段文本.  
        
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 使用有名寄存器需要额外的按键操作, 因此对于简单的操作, 最后使用 **复制专用寄存器**, 如果遇到需要将一段或者多段文本粘贴到多处的情况, 有名寄存器就会大显神通, 有名寄存器一般也用于 **宏寄存器**.

        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 用小写字母引用有名寄存器, 会覆盖该寄存器的原有内容, 而用大写字母的话, 会将新内容追加到该寄存器的原有内容之后.  
        
    - 黑洞寄存器( `"_` )
      
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 黑洞寄存器是个有去无回的地方, 可以用 `"_` 引用它. 如果运行 `"_d{mod}` 命令, vim将删除该文本且不保存任何副本. 如果只想要删除文本却不想覆盖无名寄存器中的内容, 此命令很管用, 但是不是很好按.  
        
    - 表达式寄存器( `"=` )

        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vim的寄存器通常被认为是保存一段文本的容器. 然而通过 `=` 号引用的表达式寄存器的却是一个例外. 当表达式寄存器获取内容时, vim 将跳转到命令行模式, 并显示提示符 `=` . 这时可以输入一段 vim 脚本表达式并按 `<CR>` 执行, 如果返回的是字符串(或者可以被强制转换为字符串的数据), vim将会使用它.  
        
    - 其它寄存器
    
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 可以显式地使用删除和复制命令来设置有名, 无名以及复制专用寄存器的内容. 另外, vim 还提供了己组被隐式赋值的寄存器. 它们被称为制度寄存器. 如下表所示.  
        
        | 寄存器 | 内容             |
        |--------|------------------|
        | "%     | 当前文件名       |
        | "#     | 轮换文件名       |
        | ".     | 上次插入的文本   |
        | ":     | 上次执行的Ex命令 |
        | "/     | 上次查找的模式   |
    
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 以技术上来讲, `"/` 寄存器并非只读, 可以用 `:let` 命令对其赋值, 但为了方便起见, 仍然把它放入表中, 除此之外还有 `"1` --- `"9` 这些寄存器, 这些寄存器保存着之前的动作, 每当用新动作时, 最后的这些寄存器内容都会改变. (参见 :h quote1)
    
    - 系统剪贴板 ( `"+` )和选择专用寄存器 ( `"*` )  
    
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 到目前为止, 我们所讨论的寄存器都是 vim 内部的. 如果像想从 vim 复制文本到外部程序(或者反过来), 就必须使用系统剪贴板.  
        
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vim的加号寄存器与系统剪贴板等效, 可与用 `"+` 引用.  
        
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如果在外部程序中用剪切或者复制命令获取了文本, 就可与通过 `"+p` 命令(或者在插入模式下用 `<C-r>+`) 将其粘贴到vim内部. 相反, 如果在vim的复制或删除命令前, 相印的文本将会被捕获到系统剪切板. 着意味着可以轻松地把文本粘贴到其他应用中了.  
        
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x11视窗系统支持另一种被叫做主剪贴板的剪贴板, 它保存着上次被高亮选择的文本, 可以用鼠标键把它们粘贴除了. vim的星号寄存器对于主剪贴板, 可以用 `:"*` 加以引用  
        
        x11 中的寄存器
        
        | 寄存器 | 用途                                  |
        |--------|---------------------------------------|
        | "+     | x11剪贴板, 用剪切, 复制与粘贴命令操作 |
        | "*     | x11主剪切版, 用于鼠标中键操作         |
    
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Windows 与 Mac OS X 系统并没有主剪切版的概念, 所有 `"+` 和 `"*` 可以混用, 它们都使用系统剪贴板.  
        
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x11剪切版的功能可以在编译vim时激活或禁用. 如果想验证该功能是否在自己的vim中被激活, 就可以运行 `:version` 命令, 然后找到 **xterm_clipboard** 关键字. 如果在它前面有关剑豪, 就表示这个版本的vim不支持该功能, 加号则表示已被激活.  
